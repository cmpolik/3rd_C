(x&(1<<i))? "xwr"[i%3]: '-' ???????????????????
man open 2 ????????????????


(file descriptor) open ?????????? 0600 ???? 0644
только чтение 	O_RDONLY
только запись 	O_WRONLY
и то и то    	O_RDWR
создать что-то	O_CREAT 	куда передать зачем о чем вообще
что это 	O_TRUNC	O_EXCL

что можно делать с файлом
open | write | close | lseek 		| pread | pwrite |
					не сбивает курсор
					
задача open/dprintf/close  ma

dprintf(fd, %s, arg[2]);

1) stat, lstat, statx\\\\\ 
1* fstat | fstatat 
2.1) Запись в указанный файл указанной строки open/write/close
2.2) open/dprintf/close
3.1) read/write копирование обычныйх файлов open/write all/read/close/ проверить входной файл lstat IfReg (?) chank блоки 1мб или около того и тд (может не поместится) пока read не вернет 0;
3.2) open + pread + pwrite + close
3* lstat просто файл копируем, каталог не умеем, и тд mknod/mkfifo/symlink/readlink
4) fchmod\futimens Задача 3 + сохранение + копирование прав доступа (f chmod) attime + mtime (futimens)

Еще конспект.................................
что-то о 3.1 /отдельный цикл около write один вложенный цикл в котором вызываются функции/ cyclomatic complexity про сложность алгоритма/ думать об упрощении
STAT / почему бы и не ссылаться на man/ char buf[sizeof("yyyy.mm.dd hh:mm:ss")];		f(buf, sizeof(buf)); / strftime вместо ctime и ctime_r /
что-то о 3.2 \ эммм	причем тут sqlite3 ? O.o  pread\pwrite  ааа типо разобраться с базами данных (можно а можно и нет /удаленные строки sqlite хабр)/ один фацловый дескриптор из разных потоков.

man 2 mknode ||  man mkdir to copy the empty directory. FIFO/pipe?  MKFIFO  S_LINK (2 действия читаем и создаем) readlink - читает содержимое символической ссылки. Какого размера буфер? стандарт: limits. h - тогда есть константа PATH_MAX (usefull), SYNLINK_MAX (very usefull have 0? we think yes or +1 ), take readlink| give sizeof(buf)| give link and get number of byte we have  written | %.*s (we unknown smth *) создаем с помощью simlink что и куда.
зачем-то речь о восьмеричных числах. теперь что-то о мягких и жестких ссылках.
futimens(fd, (struct timespec[]), ({sb.st_atime, sb. st_mtime})) ?????
Задача 4 используя те штуки (fchmode) сделать у результата такие же права как и оригинала ( это задача 3 + копирование части метаданнных)
Задача 5// мы не научились сохранять индентификатор владельца и группы владельца  (man 2 CHOWN) st_uid st_gid  chown\fchown (reflink) (rsync по сети программа) да давайте обработку жестких ссылок
(Если решать по уму, нужно копировать файлы быстро, значит копировать несколько потоков аааааааааааааааа да да анесколько потоков  да да копировать по сети НЕТ) hardlink +ACLs (-a) // NFS v 4
Задача 6 как работать с каталогами

атрибут файла хранится в srcurity.selinux = "system_u:object_r:etc_t:s0" (можно хранить откуда файл был скачан) xattrs // attrs (lsatr / chatr) // i // атрибуты man page chattr

-------------------------------------------------------------------------------------------------------------------------

man 7 inode повествует об индексном узле (не понел)
6 - 7 задачи временно пропускаем оказывается (и вернемся в этот раз?) 7.1|copy dir: openat/mkdiat| 7.2|copy dir (recursive)| 6.2|opendir/dirfd/fstatat/readdir/closedir| 6.1|opendir/readdir/lstat/close| 6.3 open/getdents/fstatat/close| 6.4 recursive 6.2
8* задача осознать как хранится файл	filefrag/hdparm -- fibmap
9 statvfs/statfs
9* quota/quotactl

Как прочесть содержимое каталога? 
reflinks, hardlinks
6.2 дескриптор каталога ы 
asprintf аллоцирующий принтф (не входит в стандарт, есть сторонняя библиотека) ("%s/%s", dir_path, d_name);

доделать 6.2 с учетом arg[1]	readdir(указатель дир) + fstatat(инт) + closedir  <-  |FILENO & DIRFD|	opendir+dirfd
										    <- open ? flag as directory? (odirectory) + fd opendir (каталог )
										    есть open + fd open для обычных файлов штука ( и нетолько )
readdir нету а на самом деле используется getdents 64 (но нам сюда не надо, а Шумилин говорит что надо)
6.3 ускоренное чтение больших каталогов через дерганье нестандартного системного вызова (берем сист выз на прямую ) getdents зависит от системы;(суть именно в нестандартном системном вызове)
не хотим медленно читать каталог/ оно возвращает структуру переменной длины -> проблема/\ заводим массив байт (мегабайт), есть указатель void*, (d_reclen - шапка) - длина структуры
говорят где есть пример в мане getdents64; читаем до нуля;

-----------------------------------------------------------------------------------------------------------------------------
10) inotify (7) запускаем программу и она в вечном цикле спит(потребляет 0 процессорного времени) и ждет когда что-то вернет управение (создание очереди, приписывание очереди на событие, вызывать рид и печатать то что получилось) advancelinux porogramming
11) flock/lockf/fcntl - lock (counter) считает сколько раз запускали программу, при этом изначально 0 запусков и файла нету, но если запустим 1000 раз файл не должен превратиться в непонятно что. + механизм блокировок (инструмен при безысходности).
------------------------------------------------------------------------------------------------------------------------------

|inotify| (создвние файла или перемещение в это каталог из другого) !! ЗНАТЬ РАЗНИЦУ С fanotify
11 перевести строку в число прибавть единичку, блоикровка на файл. содержимое не должно изменяться не коррректно.
--
Все в системе либо файл либо процесс (запущенные экземпляры пограммы).
PID - process identifier (ID). Находит свободный номер процесса. 			номер процесса			про иерархию
PPID - parent PID									номер его рродителя
ps | ps x -H | ps ux -eH (дерево всех)| ps aux -H (список) похоже на ps -e		

UID 	GID 	PGID	SID 	groups											про права доступа есть во всех posix совместимых системах
findbird(DB)	MDB(Access)	wait | waitpid(дожидаться только своих потомков) | waitid
есть еще:  UID + GID - effective; UID + GID - saved; UID + GID - filessystem
capabilities  дополнительные права 	||| 	SELinuxlabel
9)  th




 

